# Analog Devices ADSP-SC59x (Cortex-A55)
#
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2020-2023 Analog Devices, Inc.
#
# ADSP-SC59x devices support JTAG and SWD transports.
#
#transport select jtag
#transport select swd

source [find target/swj-dp.tcl]

set CPU_MAX_ADDRESS 0xFFFFFFFF
source [find bitsbytes.tcl]
source [find memory.tcl]
source [find mem_helper.tcl]
source [find mmr_helpers.tcl]
source [find target/adspsc5xx.tcl]
# memory map

set MAP_XML [find target/adspsc59x_memory_map.xml]
set MAP_FILE [open $MAP_XML]
set _MEMORY_MAP [read $MAP_FILE]
close $MAP_FILE

global MEMORY_MAP
global SKIP_RESET

# substitute SDRAM_SIZE and FLASH_SIZE
set MEMORY_MAP [subst $_MEMORY_MAP]
set SKIP_RESET 0

# UserKey

# Uncomment the following 4 lines and change 0x00000000 to key values
#set USERKEY0 0x00000000
#set USERKEY1 0x00000000
#set USERKEY2 0x00000000
#set USERKEY3 0x00000000

if { [info exists USERKEY0] } {
   set  _USERKEY0 $USERKEY0
} else {
   set  _USERKEY0 0x00000000
}

if { [info exists USERKEY1] } {
   set  _USERKEY1 $USERKEY1
} else {
   set  _USERKEY1 0x00000000
}

if { [info exists USERKEY2] } {
   set  _USERKEY2 $USERKEY2
} else {
   set  _USERKEY2 0x00000000
}

if { [info exists USERKEY3] } {
   set  _USERKEY3 $USERKEY3
} else {
   set  _USERKEY3 0x00000000
}

# target config

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME adspsc59x
}

# CoreSight Debug Access Port (DAP)
if { [info exists DAP_TAPID ] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x4ba06477
}

# debug control register
set TAPC_DBG_CTL 0x31131000

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_TAPID -disable -shared-connection
jtag configure $_CHIPNAME.cpu -event tap-enable "adjc_enable_dap $_CHIPNAME.adjc"

# ADI JTAG Controller
if { [info exists ADJC_TAPID ] } {
  set _ADJC_TAPID $ADJC_TAPID
} else {
  set _ADJC_TAPID 0x0282e0cb
}

jtag newtap $_CHIPNAME adjc -irlen 5 -expected-id $_ADJC_TAPID -shared-connection

# Once the JRC is up, enable our TAPs
jtag configure $_CHIPNAME.adjc -event setup "jtag tapenable $_CHIPNAME.cpu"

# GDB target:  Cortex-A5, using DAP

set _APB_AP_ADDR 0x01000000
set _AXI_AP_ADDR 0x02000000

set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_TARGETNAME -adiv6 -shared-connection

#
# AXI mem-ap target
#
target create $_CHIPNAME.apb mem_ap -dap $_CHIPNAME.dap -ap-num $_APB_AP_ADDR
target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num $_AXI_AP_ADDR

# Set CSW register value default correctly for AXI accessible device memory:
$_CHIPNAME.dap apsel $_AXI_AP_ADDR
# Clear SPROT
$_CHIPNAME.dap apcsw  0x00006000

$_CHIPNAME.dap apsel $_APB_AP_ADDR

# Unless USE_CTI is set to 0, CTI is used to restart the Cortex-A5 core
# so system peripherals can be restarted at the same time

cti create $_CHIPNAME.cti -dap $_CHIPNAME.dap -ap-num $_APB_AP_ADDR -baseaddr 0x80024000

if { [info exists USE_CTI] } {
   set _USE_CTI $USE_CTI
} else {
   set _USE_CTI 1
}
if { $_USE_CTI != 0 } {
   echo "halt and restart using CTI enabled"

   cti create $_CHIPNAME.sys_cti -dap $_CHIPNAME.dap -ap-num $_APB_AP_ADDR -baseaddr 0x8000D000 -halt-outen 1 -dbgrestart-outen 7
   target create $_TARGETNAME aarch64 -dap $_CHIPNAME.dap -dbgbase 0x80014000 -cti $_CHIPNAME.cti -syscti $_CHIPNAME.sys_cti -ap-num $_APB_AP_ADDR
} else {
   echo "halt and restart using CTI disabled"

   target create $_TARGETNAME aarch64 -dap $_CHIPNAME.dap -dbgbase 0x80014000 -cti $_CHIPNAME.cti -ap-num $_APB_AP_ADDR
}

# handle command that allows skipping a reset on attach
proc skip_reset {} {
   global SKIP_RESET

   set SKIP_RESET 1
}

# system reset
proc adspsc59x_system_reset {} {
   global _CHIPNAME
   global TAPC_DBG_CTL

   set rcu_ctl     0x3108c000
   set rcu_stat    [expr {$rcu_ctl + 0x4}]
   set rcu_crctl   [expr {$rcu_ctl + 0x8}]
   set rcu_crstat  [expr {$rcu_ctl + 0xC}]
   set rcu_bcode   [expr {$rcu_ctl + 0x28}]
   set rcu_msg     [expr {$rcu_ctl + 0x6c}]
   set rcu_msg_clr [expr {$rcu_ctl + 0x74}]

   set cti3_cticontrol  0x3110d000
   set cti3_ctiappset   [expr {$cti3_cticontrol + 0x14}]
   set cti3_ctiappclear [expr {$cti3_cticontrol + 0x18}]
   set cti3_ctiapppulse [expr {$cti3_cticontrol + 0x1c}]
   set cti3_ctiouten2   [expr {$cti3_cticontrol + 0xa8}]
   set cti3_lar         [expr {$cti3_cticontrol + 0xfb0}]

   set a55_reset_msk 0x310AD010
   
   # Enable all debug in DBG_CTL
   mww phys $TAPC_DBG_CTL 0xFFFF

   # Clear REG_RCU0_MSG
   # *pREG_RCU0_MSG = 0x0
   mww phys $rcu_msg 0

   # Deassert RSTOUT in REG_RCU0_CTL
   # *pREG_RCU0_CTL |= 0x4
   pmmw $rcu_ctl 0x4 0

   # Clear REG_RCU0_STAT
   # *pREG_RCU0_STAT = 0x7000d
   mww phys $rcu_stat 0x7000d

   # Set HALT (bit 2)
   # *pREG_RCU0_BCODE = 0x4
   mww phys $rcu_bcode 0x4

   # Use CTI to do system reset
   # Unlock CTI3 (System CTI)
   # *pREG_CTI3_LAR = 0xC5ACCE55
   mww phys $cti3_lar 0xC5ACCE55

   # Enable CTI3 (System CTI)
   # *pREG_CTI3_CTICONTROL = 1
   mww phys $cti3_cticontrol 0x1

   # Connect CTITRIGOUT[2] of CTI3 to channel 2
   mww phys $cti3_ctiouten2 0x4

   # Set RESET_CTLRSTMSK for warm reset(debug stays alive)
   mem_ap_write_reg $a55_reset_msk 0xB6

   mww phys $cti3_ctiapppulse 0x4

   # Wait till Core 0 is idle
   # while((*pREG_RCU0_MSG & BITM_RCU_MSG_C0IDLE) == 0);
   set data 0
   set retry 0
   while { [expr {$data & 0x100}] == 0 } {
      set data [mem_ap_read_reg $rcu_msg]
      set retry [expr {$retry + 1}]
      if { $retry > 20 } break;
   }
   if { $retry > 20 } {
      set msg [format 0x%08x $data]
      log_error "BCODE.HALT failed (REG_RCU0_MSG $msg)"
   }

   # Clear C0IDLE from REG_RCU0_MSG
   # *pREG_RCU0_MSG_CLR = 0x100
   mem_ap_write_reg $rcu_msg_clr 0x100

   # Now BOOT is done
   echo "system reset done"

   # clear REG_RCU0_MSG
   mem_ap_write_reg $rcu_msg 0

   # clear REG_RCU0_BCODE
   mem_ap_write_reg $rcu_bcode 0

   # Disable CTI3 (System CTI)
   mem_ap_write_reg $cti3_cticontrol 0
}

# core reset
proc adspsc59x_core_reset {} {
   global _CHIPNAME
   global TAPC_DBG_CTL

   set rcu_ctl       0x3108c000
   set rcu_stat      [expr {$rcu_ctl + 0x4}]
   set rcu_crctl     [expr {$rcu_ctl + 0x8}]
   set rcu_crstat    [expr {$rcu_ctl + 0xC}]
   set rcu_bcode     [expr {$rcu_ctl + 0x28}]
   set rcu_svect0    [expr {$rcu_ctl + 0x2C}]
   set rcu_svect1    [expr {$rcu_ctl + 0x30}]
   set rcu_svect2    [expr {$rcu_ctl + 0x34}]
   set rcu_msg       [expr {$rcu_ctl + 0x6c}]
   set rcu_msg_clr   [expr {$rcu_ctl + 0x74}]

   mem_ap_write_reg $TAPC_DBG_CTL 0xFFFF

   # Read BMODE from RCU0_STAT
   set data [mem_ap_read_reg $rcu_stat]
   set bootmode [expr {($data >> 8) & 0xf}]

   # Clear RCU regs
   mem_ap_write_reg $rcu_ctl 0
   mem_ap_write_reg $rcu_crctl 0
   mem_ap_write_reg $rcu_crstat 0xFFFFFFF9

   # Set HALT (bit 2)
   # *pREG_RCU0_BCODE = 0x4
   mem_ap_write_reg $rcu_bcode 0x4

   # Set ARM starting address
   # *pREG_RCU0_SVECT0 = 0x40
   mem_ap_write_reg $rcu_svect0 0x40

   # Set SHARC cores to entry points
   # *pREG_RCU0_SVECT1 = 0x00500004
   # *pREG_RCU0_SVECT2 = 0x00500004
   mem_ap_write_reg $rcu_svect1 0x00500004
   mem_ap_write_reg $rcu_svect2 0x00500004

   # clear CRn bit in CRSTAT register( bit is W1C )
   # *pREG_RCU0_CRSTAT = 0x1
   mem_ap_write_reg $rcu_crstat 0x1

   # clear CRCTL
   # *pREG_RCU0_CRCTL = 0x0
   mem_ap_write_reg $rcu_crctl 0

   # set bit 0 in CRCTL
   # *pREG_RCU0_CRCTL |= 0x1
   mem_ap_write_reg $rcu_crctl 0x1

   # Wait till Core 0 is in reset
   set data 0
   set retry 0
   while { [expr {$data & 0x1}] == 0 } {
      set data [mem_ap_read_reg $rcu_crstat]
      set retry [expr {$retry + 1}]
      if { $retry > 20 } break;
   }
   if { $retry > 20 } {
      set msg [format 0x%08x $data]
      log_error "Core was not put in reset"
   }

   # small delay to give reset time to take affect
   sleep 100

   # clear bit 0 in CRCTL
   set data [mem_ap_read_reg $rcu_crctl]
   set rcu_crctl_data  [expr {$data & 0xFFFFFFFE}]
   mem_ap_write_reg $rcu_crctl $rcu_crctl_data

   echo "core reset complete"
}

$_TARGETNAME configure -event reset-assert {
   adspsc59x_system_reset
   #adspsc59x_core_reset
}

# read register using mem-ap
proc mem_ap_read_reg {register} {
    global _CHIPNAME
    return [$_CHIPNAME.axi read_memory $register 32 1]
}

proc mem_ap_write_reg {register data} {
    global _CHIPNAME
    $_CHIPNAME.axi write_memory $register 32 $data
}

# Initialize the eMSI
proc adspsc59x_a55_init_emsi {} {
   set emsi_clk_ctl 0x310C702C

   # Set the Internal Clock Enable bit and wait for clock synchronization
   # *pREG_EMSI0_CLK_CTL |= BITM_EMSI_CLK_CTL_INTERNAL_CLK_EN
   # while(!(*pREG_EMSI0_CLK_CTL & BITM_EMSI_CLK_CTL_INTERNAL_CLK_STABLE))
   pmmw $emsi_clk_ctl 0x1 0x0
   set data [memread32_phys $emsi_clk_ctl]
   while { ![expr {$data & 0x00000002}] } {
      set data [memread32_phys $emsi_clk_ctl]
   }

   # Set the PLL Enable bit and wait for clock synchronization
   # *pREG_EMSI0_CLK_CTL |= BITM_EMSI_CLK_CTL_PLL_EN;
   # while(!(*pREG_EMSI0_CLK_CTL & BITM_EMSI_CLK_CTL_INTERNAL_CLK_STABLE))
   pmmw $emsi_clk_ctl 0x8 0x0
   set data [memread32_phys $emsi_clk_ctl]
   while { ![expr {$data & 0x00000002}] } {
      set data [memread32_phys $emsi_clk_ctl]
   }
}

# default initialization
proc adspsc59x_a55_init {} {
   adspsc59x_a55_init_emsi
}

$_TARGETNAME configure -event gdb-attach {
   if {[$_TARGETNAME curstate] == "running"} { halt}

   # read TAPC_IDCODE to get silicon revision
   # silicon revision 0.0 and 0.1 do not support system reset
   set data [mem_ap_read_reg 0x31130000]

   if { $SKIP_RESET == 0 } {
      reset
      halt
   }

   adspsc59x_a55_init

   arm semihosting enable
}

reset_config trst_only

$_TARGETNAME configure -event reset-assert-post "aarch64 dbginit"

gdb_memory_map disable
